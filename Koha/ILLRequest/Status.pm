package Koha::ILLRequest::Status;

# Copyright PTFS Europe 2014
#
# This file is part of Koha.
#
# Koha is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
#
# Koha is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with Koha; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

use Modern::Perl;
use DateTime;
use Carp;

=head1 NAME

Koha::ILLRequest::Status - Koha ILL Status Object class

=head1 SYNOPSIS

=head1 DESCRIPTION

Currently this is hardcoded to database column names and there is no
configuration to map the fields to relevant fields in the API.  So for now it
is hard-coded to use BLDSS API.

=head1 API

=head2 Class Methods

=cut

=head3 new

=cut

sub new {
    my ( $class, $opts ) = @_;
    my $status = 'New Request';
    $status = 'Queued' unless ( $opts->{permitted} );

    # `id` will be autogenerated when saved to db
    # `reply_date` & `completion_date` will bo populated at a later date.
    # `borrower`: we store an extra field, which is ignored for db writes: a
    #             Koha Borrower object.
    my $brwNum = '';
    $brwNum = $opts->{borrower}->borrowernumber
        if ( $opts->{borrower} );
    my $self = {
        borrower        => $opts->{borrower} || '',
        borrowernumber  => $brwNum || 0,
        biblionumber    => 0,
        status          => $status,
        placement_date  => DateTime->now,
        ts              => DateTime->now,
        reqtype         => $opts->{reqtype}  || '',
        branch          => $opts->{branch}   || '',
    };

    bless $self, $class;

    return $self;
}

sub getFields {
    my ( $self, $params ) = @_;
    my $return = {
        id              => $self->{id},
        biblionumber    => $self->{biblionumber},
        status          => $self->{status},
        placement_date  => $self->{placement_date},
        reply_date      => $self->{reply_date},
        ts              => $self->{ts},
        completion_date => $self->{completion_date},
        reqtype         => $self->{reqtype},
        branch          => $self->{branch},
    };
    # Add borrower or borrowernumber.
    if ( $params->{brw} ) {
        $return->{borrower} = $self->{borrower};
    } else {
        $return->{borrowernumber} = $self->{borrowernumber};
    }
    return $return;
}

=head3 getProperty

    my $fieldvalue = $illRequest->getProperty($FIELDNAME);

Return the value of field $FIELDNAME or 0 if it does not exist.

=cut

sub getProperty {
    my ( $self, $property, $prefix ) = @_;
    return $prefix . $self->{id} if ( 'id' eq $property and $prefix );
    return $self->{$property} || 0;
}

sub getFullStatus {
    my ( $self, $params ) = @_;

    my $return = {
        id              => [ "Request Number", $self->{id} ],
        biblionumber    => [ "Item Number", $self->{biblionumber} ],
        status          => [ "Status", $self->{status} ],
        placement_date  => [ "Placement Date", $self->{placement_date} ],
        reply_date      => [ "Response Date", $self->{reply_date} ],
        ts              => [ "Timestamp", $self->{ts} ],
        completion_date => [ "Completion Date", $self->{completion_date} ],
        reqtype         => [ "Request Type", $self->{reqtype} ],
        branch          => [ "Branch", $self->{branch} ],
    };
    # Add borrower or borrowernumber.
    if ( $params->{brw} ) {
        $return->{borrower} = [ "Borrower", $self->{borrower} ]
    } else {
        $return->{borrowernumber}
            = [ "Borrower Number", $self->{borrowernumber} ];
    }
    # Add ID with prefix
    $return->{prefix_id} = [
        "Request Number", $params->{id_prefix} . $self->{id}
    ];
    return $return;
}

sub getSummary {
    my ( $self, $params ) = @_;
    my $return = {
        id             => [ "Request Number", $self->{id} ],
        biblionumber   => [ "Item Number", $self->{biblionumber} ],
        status         => [ "Status", $self->{status} ],
        reqtype        => [ "Request Type", $self->{reqtype} ],
    };
    # Add borrower or borrowernumber.
    if ( $params->{brw} ) {
        $return->{borrower} = [ "Borrower", $self->{borrower} ]
    } else {
        $return->{borrowernumber}
            = [ "Borrower Number", $self->{borrowernumber} ];
    }
    # Add ID with prefix
    $return->{prefix_id} = [
        "Request Number", $params->{id_prefix} . $self->{id}
    ];
    return $return;
}

=head3 update

    my $modified_status = $illRequest->update($new_values);

Modify our properties with the values of the corresponding properties passed
as the hashref $NEW_VALUES.

=cut

sub update {
    my ( $self, $new_values ) = @_;

    foreach my $field ( keys %{$self} ) {
        my $new_value = $new_values->{$field};
        $self->{$field} = $new_value if $new_value;
    }

    $self->{ts} = DateTime->now;

    return $self;
}


=head3 create_from_store


=cut

sub create_from_store {
    my ( $self, $attributes ) = @_;

    foreach my $field ( keys %{$self} ) {
        ${$self}{$field} = ${$attributes}{$field};
    }
    # Finally: we should retrieve 'id' if it exists.
    ${$self}{id} = ${$attributes}{id}
      if ${$attributes}{id};

    return $self;
}

=head1 AUTHOR

Alex Sassmannshausen <alex.sassmannshausen@ptfs-europe.com>

=cut

1;
